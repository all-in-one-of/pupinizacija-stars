<script src="../lib/FBOUtils.js"></script>

<dom-module id="main-app">
  <style>
    :host > #controls {
      position: absolute;
    }
    :host paper-button {
      background: gray;
    }
  </style>
  <template>
    <div id="controls">
      <paper-button on-tap="animStars0">stars0</paper-button>
      <paper-button on-tap="animStars1">stars1</paper-button>
      <paper-button on-tap="animHead0">head0</paper-button>
      <paper-button on-tap="animHead1">head1</paper-button>
      <paper-button on-tap="animHead2">head2</paper-button>
      <div>stars</div>
      <paper-slider value="{{forceStars}}" editable min="0" max="100"></paper-slider>
      <div>head</div>
      <paper-slider value="{{forceHead}}" editable min="0" max="100"></paper-slider>
      <div>field</div>
      <paper-slider value="{{forceField}}" editable min="0" max="100"></paper-slider>
      <div>color</div>
      <paper-slider value="{{color}}" editable min="0" max="100"></paper-slider>
    </div>
  </template>
</dom-module>
<script>
(function () {

  var renderer = new THREE.WebGLRenderer({antialias: true});

  var scene = new THREE.Scene();

  var camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0.2, 1.5);
  camera.lookAt(new THREE.Vector3(0.0, 0.2, 0.0));

  var dataTexturePosition = new THREE.DataTexture(null, 512, 512, THREE.RGBFormat, THREE.FloatType);
  dataTexturePosition.magFilter = THREE.NearestFilter;
  dataTexturePosition.minFilter = THREE.NearestFilter;
  dataTexturePosition.generateMipmaps = false;

  var xhr = new XMLHttpRequest();
  xhr.responseType = 'arraybuffer';
  xhr.open('GET', 'model/head.position.bin', true);
  xhr.onload = function() {
    var buffer = new Float32Array(xhr.response);
    dataTexturePosition.image.data = buffer;
    dataTexturePosition.needsUpdate = true;
  };
  xhr.send();

  var dataTextureColor = new THREE.DataTexture(null, 512, 512, THREE.RGBFormat, THREE.FloatType);
  dataTextureColor.magFilter = THREE.NearestFilter;
  dataTextureColor.minFilter = THREE.NearestFilter;
  dataTextureColor.generateMipmaps = false;

  var xhr2 = new XMLHttpRequest();
  xhr2.responseType = 'arraybuffer';
  xhr2.open('GET', 'model/head.color.bin', true);
  xhr2.onload = function() {
    var buffer = new Float32Array(xhr2.response);
    dataTextureColor.image.data = buffer;
    dataTextureColor.needsUpdate = true;
  };
  xhr2.send();

  var dataTextureStars = new THREE.DataTexture(null, 512, 512, THREE.RGBFormat, THREE.FloatType);
  dataTextureStars.magFilter = THREE.NearestFilter;
  dataTextureStars.minFilter = THREE.NearestFilter;
  dataTextureStars.generateMipmaps = false;

  var xhr3 = new XMLHttpRequest();
  xhr3.responseType = 'arraybuffer';
  xhr3.open('GET', 'model/stars.bin', true);
  xhr3.onload = function() {
    var buffer = new Float32Array(xhr3.response);
    dataTextureStars.image.data = buffer;
    dataTextureStars.needsUpdate = true;
  };
  xhr3.send();

  var dataTextureRandom = new THREE.DataTexture(null, 512, 512, THREE.RGBFormat, THREE.FloatType);
  dataTextureRandom.magFilter = THREE.NearestFilter;
  dataTextureRandom.minFilter = THREE.NearestFilter;
  dataTextureRandom.generateMipmaps = false;

  var xhr4 = new XMLHttpRequest();
  xhr4.responseType = 'arraybuffer';
  xhr4.open('GET', 'model/random.bin', true);
  xhr4.onload = function() {
    var buffer = new Float32Array(xhr4.response);
    dataTextureRandom.image.data = buffer;
    dataTextureRandom.needsUpdate = true;
  };
  xhr4.send();

  /////

  var size = 512;
  var count = size * size;

  var particleGeometry = new THREE.BufferGeometry();
  particleGeometry.attributes = {
    position: {
      itemSize: 3,
      array: new Float32Array(count * 3),
      numItems: count * 3
    },
    uv: {
      itemSize: 2,
      array: new Float32Array(count * 2),
      numItems: count * 2
    }
  };
  var positions = particleGeometry.attributes.position.array;
  var uvs = particleGeometry.attributes.uv.array;

  for (var i = 0; i < count; i ++) {
    // positions
    positions[i * 3]     = Math.random();
    positions[i * 3 + 1] = Math.random();
    positions[i * 3 + 2] = Math.random();
    // uvs
    uvs[i * 2]     = (i % size + 0.5) / size;
    uvs[i * 2 + 1] = (Math.floor(i / size + 0.5)) / size;
  }
  particleGeometry.computeBoundingSphere();

  var particleMaterial = new THREE.ShaderMaterial({

    uniforms: {
      tPositions: { type: "t", value: dataTexturePosition },
      tColors: { type: "t", value: dataTextureColor },
      tRandom: { type: "t", value: dataTextureRandom },
      fColor: { type: "f", value: 0 },
      pointSize: { type: "f", value: 2 }
    },

    vertexShader: [

			'uniform sampler2D tPositions;',
			'uniform sampler2D tRandom;',
			'uniform float pointSize;',
			'uniform float fColor;',

			'varying vec2 vUv;',

			'void main() {',

      ' vUv = uv;',

      ' vec3 texPosition = texture2D(tPositions, uv).rgb;',

      ' vec4 mvPosition = modelViewMatrix * vec4(texPosition, 1.0);',

      ' gl_Position = projectionMatrix * mvPosition;',

      ' float starSize = 3.0 * (10.0 / length(mvPosition.xyz));',

      ' gl_PointSize = mix(starSize, 1.5, fColor) * (texture2D(tRandom, uv).r + 0.5) * pointSize;',

			'}'

		].join('\n'),

		fragmentShader: [

			'uniform sampler2D tColors;',
			'uniform sampler2D tRandom;',
			'uniform float fColor;',

			'varying vec2 vUv;',

			'void main() {',

      ' vec3 headColor = texture2D(tColors, vUv).rgb;',
      ' vec3 randColor = texture2D(tRandom, vUv).rgb;',
      ' vec3 starColor = vec3(0.8) + (randColor * 0.4);',

			'	gl_FragColor = mix(vec4(starColor, 0.5 + randColor.b / 2.0), vec4(headColor, 1.0), fColor);',

			'}'

		].join('\n'),

    transparent: true
    // blending: THREE.AdditiveBlending,
    // depthTest: false

  });

  var particleMesh = new THREE.PointCloud(particleGeometry, particleMaterial);
  scene.add(particleMesh);

  /////

  var simulationShader = new THREE.ShaderMaterial({

    uniforms: THREE.UniformsUtils.merge([{

      tOldPos: { type: "t", value: null },
      tTargetHead: { type: "t", value: null },
      tTargetStars: { type: "t", value: null },

      fForceStars: { type: "f", value: 1 },
      fForceHead: { type: "f", value: 1 },
      fForceField: { type: "f", value: 1 }

    }, field.uniforms]),

    vertexShader: [

      'varying vec2 vUv;',

      'void main() {',

      '	vUv = uv; ',

      '	gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1);',

      '}'

		].join('\n'),

		fragmentShader: [

      field.shaderChunk.params,

			'uniform sampler2D tOldPos;',
			'uniform sampler2D tTargetHead;',
			'uniform sampler2D tTargetStars;',

			'uniform float fForceStars;',
			'uniform float fForceHead;',
			'uniform float fForceField;',

			'varying vec2 vUv;',

      field.shaderChunk.functions,

			'void main() {',

      ' vec3 oldPos = texture2D(tOldPos, vUv).rgb;',

      ' vec3 field = getField(ftex, ftrans, finvTrans, oldPos, fgrid, fForceField);',

      ' vec3 targetHead = (texture2D(tTargetHead, vUv).rgb * 10. - oldPos) * fForceHead;',

      ' vec3 targetStars = (texture2D(tTargetStars, vUv).rgb * 40. - oldPos) * fForceStars;',

			'	gl_FragColor = vec4(oldPos + targetStars + targetHead + field, 1.0);',

			'}'

		].join('\n')

  });

  var fbo = new THREE.FBOUtils( 512, renderer, simulationShader );

  /////

  scene.add(field.transform);

  Polymer({
    is: 'main-app',
    properties: {
      forceStars: {
        value: 0,
      },
      forceHead: {
        value: 100,
      },
      forceField: {
        value: 0,
      },
      color: {
        value: 0
      }
    },
    ready: function () {

      this.appendChild(renderer.domElement);
      renderer.setSize(window.innerWidth, window.innerHeight);

      window.addEventListener('resize', function() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });

      this._loop = this.loop.bind(this);
      this._loop();

    },
    animStars0: function () {
      this.forceStars = 100;
      this.forceHead = 0;
      this.forceField = 10;
      this.color = 0;
    },
    animStars1: function () {
      this.forceStars = 1;
      this.forceHead = 0;
      this.forceField = 10;
      this.color = 0;
    },
    animHead0: function () {
      this.forceStars = 2;
      this.forceHead = 2;
      this.forceField = 100;
      this.color = 10;
    },
    animHead1: function () {
      this.forceStars = 5;
      this.forceHead = 80;
      this.forceField = 50;
      this.color = 25;
    },
    animHead2: function () {
      this.forceStars = 0;
      this.forceHead = 100;
      this.forceField = 0;
      this.color = 75;
    },
    loop: function () {

      // setTimeout(function(){
        requestAnimationFrame(this._loop);
      // }.bind(this), 1000 / 12); // temp

      camera.position.z = 25 + 3 * Math.sin(Date.now()/1000);
      camera.position.y = 0 - 0.5 * Math.abs(Math.cos(Date.now()/1000));

      field.update();
      simulationShader.uniforms.tOldPos.value = fbo.out;
      simulationShader.uniforms.tTargetHead.value = dataTexturePosition;
      simulationShader.uniforms.tTargetStars.value = dataTextureStars;

      simulationShader.uniforms.fForceStars.value = this.forceStars / 4000;
      simulationShader.uniforms.fForceHead.value = this.forceHead / 4000;
      simulationShader.uniforms.fForceField.value = this.forceField / 40000;
      //
      simulationShader.uniforms.ftex.value = field.texture;
      simulationShader.uniforms.ftrans.value = field.uniforms.ftrans.value;
      simulationShader.uniforms.finvTrans.value = field.uniforms.finvTrans.value;

      fbo.swap();
      fbo.simulate();

      particleMaterial.uniforms.tPositions.value = fbo.out;
      particleMaterial.uniforms.fColor.value = this.color / 100;

      renderer.render(scene, camera);

    }

  });
}());
</script>
