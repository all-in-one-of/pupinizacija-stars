<script src="../lib/FBOUtils.js"></script>

<script src="../post/CopyShader.js"></script>
<script src="../post/ConvolutionShader.js"></script>

<script src="../post/EffectComposer.js"></script>
<script src="../post/RenderPass.js"></script>
<script src="../post/MaskPass.js"></script>
<script src="../post/ShaderPass.js"></script>
<script src="../post/BloomPass.js"></script>

<dom-module id="main-app">
  <style>
    :host {
      cursor: none;
    }
    :host > #controls {
      position: absolute;
    }
    :host paper-button {
      background: gray;
    }
    :host > #subtitle {
      position:absolute;
      bottom: 0;
      color: white;
      text-align: center;
      width: 100%;
      padding: 0.5em 2em;
      font-size: 1.2rem;
      text-shadow: 0.05em 0.05em 0 black;
    }
  </style>
  <template>
    <audio src="../audio/Pupin12.wav" preload="auto" id="audio"></audio>
    <div id="controls">
      <template is="dom-if" if="{{animReady}}">
        <paper-button on-tap="animReset">Reset</paper-button>
        <paper-button on-tap="animGo">Go</paper-button>
      </template>
      <div>stars</div>
      <paper-slider value="{{forceStars}}" editable min="0" max="100"></paper-slider>
      <div>head</div>
      <paper-slider value="{{forceHead}}" editable min="0" max="100"></paper-slider>
      <div>field</div>
      <paper-slider value="{{forceField}}" editable min="0" max="100"></paper-slider>
      <div>center</div>
      <paper-slider value="{{forceCenter}}" editable min="0" max="100"></paper-slider>
      <div>color</div>
      <paper-slider value="{{color}}" editable min="0" max="100"></paper-slider>
    </div>
    <div id="subtitle">{{currentTitle}}</div>
  </template>
</dom-module>
<script>
(function () {

  var renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.autoClear = false;

  var scene = new THREE.Scene();

  var camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0.2, 25);
  camera.lookAt(new THREE.Vector3(0.0, 0.2, 0.0));

  var composer = new THREE.EffectComposer(renderer);
  composer.setSize(window.innerWidth, window.innerHeight);

  var scenePass = new THREE.RenderPass(scene, camera);
  composer.addPass(scenePass);

  var bloomPass = new THREE.BloomPass(2, 25, 4, 1024);
  THREE.BloomPass.blurX.x /= window.innerWidth / window.innerHeight;
  composer.addPass( bloomPass );

  var copyPass = new THREE.ShaderPass( THREE.CopyShader );
  copyPass.renderToScreen = true;
  composer.addPass(copyPass);

  var dataTexturePosition = new THREE.DataTexture(null, 512, 512, THREE.RGBFormat, THREE.FloatType);
  dataTexturePosition.magFilter = THREE.NearestFilter;
  dataTexturePosition.minFilter = THREE.NearestFilter;
  dataTexturePosition.generateMipmaps = false;

  var xhr = new XMLHttpRequest();
  xhr.responseType = 'arraybuffer';
  xhr.open('GET', 'model/pupin.position.bin', true);
  xhr.onload = function() {
    var buffer = new Float32Array(xhr.response);
    dataTexturePosition.image.data = buffer;
    dataTexturePosition.needsUpdate = true;
  };
  xhr.send();

  var dataTextureColor = new THREE.DataTexture(null, 512, 512, THREE.RGBFormat, THREE.FloatType);
  dataTextureColor.magFilter = THREE.NearestFilter;
  dataTextureColor.minFilter = THREE.NearestFilter;
  dataTextureColor.generateMipmaps = false;

  var xhr2 = new XMLHttpRequest();
  xhr2.responseType = 'arraybuffer';
  xhr2.open('GET', 'model/pupin.color.bin', true);
  xhr2.onload = function() {
    var buffer = new Float32Array(xhr2.response);
    dataTextureColor.image.data = buffer;
    dataTextureColor.needsUpdate = true;
  };
  xhr2.send();

  var dataTextureStars = new THREE.DataTexture(null, 512, 512, THREE.RGBFormat, THREE.FloatType);
  dataTextureStars.magFilter = THREE.NearestFilter;
  dataTextureStars.minFilter = THREE.NearestFilter;
  dataTextureStars.generateMipmaps = false;

  var xhr3 = new XMLHttpRequest();
  xhr3.responseType = 'arraybuffer';
  xhr3.open('GET', 'model/stars.bin', true);
  xhr3.onload = function() {
    var buffer = new Float32Array(xhr3.response);
    dataTextureStars.image.data = buffer;
    dataTextureStars.needsUpdate = true;
  };
  xhr3.send();

  var dataTextureRandom = new THREE.DataTexture(null, 512, 512, THREE.RGBFormat, THREE.FloatType);
  dataTextureRandom.magFilter = THREE.NearestFilter;
  dataTextureRandom.minFilter = THREE.NearestFilter;
  dataTextureRandom.generateMipmaps = false;

  var xhr4 = new XMLHttpRequest();
  xhr4.responseType = 'arraybuffer';
  xhr4.open('GET', 'model/random.bin', true);
  xhr4.onload = function() {
    var buffer = new Float32Array(xhr4.response);
    dataTextureRandom.image.data = buffer;
    dataTextureRandom.needsUpdate = true;
  };
  xhr4.send();

  var subtitleData = [];

  var xhr5 = new XMLHttpRequest();
  xhr5.responseType = 'text';
  xhr5.open('GET', 'audio/subtitles.srt', true);
  xhr5.onload = function() {
    subtitleData = parser.fromSrt(xhr5.response, true);
  };
  xhr5.send();

  /////


  var size = 512;
  var count = size * size;

  var particleGeometry = new THREE.BufferGeometry();
  particleGeometry.attributes = {
    position: {
      itemSize: 3,
      array: new Float32Array(count * 3),
      numItems: count * 3
    },
    uv: {
      itemSize: 2,
      array: new Float32Array(count * 2),
      numItems: count * 2
    }
  };
  var positions = particleGeometry.attributes.position.array;
  var uvs = particleGeometry.attributes.uv.array;

  for (var i = 0; i < count; i ++) {
    // positions
    positions[i * 3]     = Math.random();
    positions[i * 3 + 1] = Math.random();
    positions[i * 3 + 2] = Math.random();
    // uvs
    uvs[i * 2]     = (i % size + 0.5) / size;
    uvs[i * 2 + 1] = (Math.floor(i / size + 0.5)) / size;
  }
  particleGeometry.computeBoundingSphere();

  var particleMaterial = new THREE.ShaderMaterial({

    uniforms: {
      tPositions: { type: "t", value: dataTexturePosition },
      tColors: { type: "t", value: dataTextureColor },
      tRandom: { type: "t", value: dataTextureRandom },
      fColor: { type: "f", value: 0 },
      pointSize: { type: "f", value: 2 }
    },

    vertexShader: [

			'uniform sampler2D tPositions;',
			'uniform sampler2D tRandom;',
			'uniform float pointSize;',
			'uniform float fColor;',

			'varying vec2 vUv;',
			'varying float fFade;',

			'void main() {',

      ' vUv = uv;',

      ' vec3 texPosition = texture2D(tPositions, uv).rgb;',

      ' vec4 mvPosition = modelViewMatrix * vec4(texPosition, 1.0);',

      ' gl_Position = projectionMatrix * mvPosition;',

      ' float starSize = 3.0 * (10.0 / length(mvPosition.xyz));',

      ' gl_PointSize = mix(starSize * (texture2D(tRandom, uv).r + 0.5) * pointSize, 1.0, fColor);',
      ' fFade = min(1.0, gl_PointSize);',
      ' gl_PointSize = max(gl_PointSize, 1.0);',

			'}'

		].join('\n'),

		fragmentShader: [

			'uniform sampler2D tColors;',
			'uniform sampler2D tRandom;',
			'uniform float fColor;',

			'varying vec2 vUv;',
			'varying float fFade;',

			'void main() {',

      ' vec3 headColor = texture2D(tColors, vUv).rgb;',
      ' vec3 randColor = texture2D(tRandom, vUv).rgb;',
      ' vec3 starColor = vec3(0.8) + (randColor * 0.4);',

			'	gl_FragColor = mix(vec4(starColor, 0.8 + randColor.b * 0.2), vec4(headColor, 1.0), fColor);',

      ' vec2 pos = gl_PointCoord.xy - vec2(0.5);',
      ' if (fFade == 1.0 && length(pos) > 0.5) {',
      '   gl_FragColor.a = 0.0;',
      ' }',

      ' gl_FragColor.a *= fFade;',

      ' if (vUv.x < 0.3) {',

      '  gl_FragColor.xyz = starColor;',

      ' }',

			'}'

		].join('\n'),

    transparent: true
    // blending: THREE.AdditiveBlending,
    // depthTest: false

  });

  var particleMesh = new THREE.PointCloud(particleGeometry, particleMaterial);
  scene.add(particleMesh);

  /////

  var simulationShader = new THREE.ShaderMaterial({

    uniforms: THREE.UniformsUtils.merge([{

      tOldPos: { type: "t", value: null },
      tTargetHead: { type: "t", value: null },
      tTargetStars: { type: "t", value: null },

      fForceStars: { type: "f", value: 1 },
      fForceHead: { type: "f", value: 1 },
      fForceField: { type: "f", value: 1 },
      fForceCenter: { type: "f", value: 1 },
      vCenter: { type: "v3", value: new THREE.Vector3(0,0,0) },

    }, field.uniforms]),

    vertexShader: [

      'varying vec2 vUv;',

      'void main() {',

      '	vUv = uv; ',

      '	gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1);',

      '}'

		].join('\n'),

		fragmentShader: [

      field.shaderChunk.params,

			'uniform sampler2D tOldPos;',
			'uniform sampler2D tTargetHead;',
			'uniform sampler2D tTargetStars;',

			'uniform float fForceStars;',
			'uniform float fForceHead;',
			'uniform float fForceField;',
			'uniform float fForceCenter;',
			'uniform vec3  vCenter;',

			'varying vec2 vUv;',

      field.shaderChunk.functions,

			'void main() {',

      ' vec3 oldPos = texture2D(tOldPos, vUv).rgb;',

      ' vec3 field = getField(ftex, ftrans, finvTrans, oldPos, fgrid, 1.0);',

      ' vec3 texHead = texture2D(tTargetHead, vUv).rgb * 1.7 + vec3(0.0, -2.8, 0.0);',
      ' vec3 targetHead = (texHead - oldPos) * fForceHead;',

      ' vec3 texStars = texture2D(tTargetStars, vUv).rgb * 40.0;',
      ' vec3 targetStars = (texStars - oldPos) * fForceStars;',

      ' vec3 centerDist = vCenter - oldPos;',
      ' vec3 targetCenter = centerDist / (max(length(centerDist), 0.0001) * 10.0);',
      ' targetCenter += field * 0.01 * fForceCenter;',
      ' targetCenter *= fForceCenter;',

			'	gl_FragColor = vec4(oldPos + targetStars + targetHead + field * fForceField + targetCenter, 1.0);',

      ' if (vUv.x < 0.2) {',

      '  gl_FragColor.xyz = texStars;',

      ' }',

			'}'

		].join('\n')

  });

  var fbo = new THREE.FBOUtils(512, renderer, simulationShader);

  scene.add(field.transform);

  /////

  var socket;

  Polymer({
    is: 'main-app',
    properties: {
      forceStars: {
        value: 0,
      },
      forceHead: {
        value: 100,
      },
      forceField: {
        value: 0,
      },
      forceCenter: {
        value: 0,
      },
      color: {
        value: 0
      },
      currentTitle: {
        value: ''
      }
    },
    ready: function () {

      this.appendChild(renderer.domElement);

      var resizeApp = function() {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        composer.setSize(window.innerWidth, window.innerHeight);
      };

      window.addEventListener('resize', resizeApp);

      setTimeout(function () {
        resizeApp();
      }, 3000);

      this._loop = this.loop.bind(this);
      this._loop();

      this.animReset();

    },
    animReset: function () {
      this.animReady = false;
      this.$.audio.pause();
      new TWEEN.Tween(this).to({
        forceStars: 100,
        forceHead: 0,
        forceField: 10,
        color: 0 }, 5000)
      .easing(TWEEN.Easing.Quadratic.InOut)
      .onComplete(function () {
        setTimeout(function () {
          this.animReady = true;
          console.log('ready');
        }.bind(this), 1000);
      }.bind(this))
      .start();
    },
    animGo: function () {
      if (!this.animReady) {
        return;
      }
      this.animReady = false;
      new TWEEN.Tween(this).to({
        forceStars: 12,
        forceHead: 0,
        forceField: 10,
        color: 0 }, 5000)
      .easing(TWEEN.Easing.Quadratic.InOut)
      .onComplete(function () {

        console.log('Play audio');
        this.$.audio.currentTime = 0;
        this.$.audio.play();

        new TWEEN.Tween(this).to({
          forceStars: 5,
          forceHead: 3,
          forceField: 25,
          color: 0 }, 38000)
        .easing(TWEEN.Easing.Quadratic.InOut)
        .onComplete(function () {

          console.log('done 0');

          new TWEEN.Tween(this).to({
            forceStars: 0,
            forceHead: 5,
            forceField: 35,
            color: 2 }, 27000)
          .easing(TWEEN.Easing.Quadratic.InOut)
          .onComplete(function () {

            console.log('done 1');

            new TWEEN.Tween(this).to({
              forceStars: 0,
              forceHead: 20,
              forceField: 60,
              color: 4 }, 2000)
            .easing(TWEEN.Easing.Quadratic.InOut)
            .onComplete(function () {

              console.log('done 2');

              new TWEEN.Tween(this).to({
                forceHead: 40,
                forceField: 0,
                color: 10 }, 10000)
              .easing(TWEEN.Easing.Quadratic.InOut)
              .onComplete(function () {

                console.log('done 3');

                new TWEEN.Tween(this).to({
                  color: 90 }, 10000)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .onComplete(function () {

                  console.log('done 4');
                  this.animReady = true;

                }.bind(this))
                .start();


              }.bind(this))
              .start();

            }.bind(this))
            .start();

          }.bind(this))
          .start();

        }.bind(this))
        .start();

      }.bind(this))
      .start();

    },

    loop: function () {

      // setTimeout(function(){
        requestAnimationFrame(this._loop);
      // }.bind(this), 1000 / 12); // temp

      if (!socket && window.location.href.search('localhost') !== -1) {
        socket = new WebSocket('ws://localhost:7000');
        socket.onopen = function(msg) {
          console.log('WebSocket connected.')
        }
        socket.onmessage = function(msg) {
          // console.log(msg);
          camera.position.z = Number(msg.data) / 16 + 22;
        }
        socket.onclose = function() {
          socket = null;
        }
      }

      TWEEN.update();

      this.currentTitle = '';
      for (var i = 0; i < subtitleData.length; i++) {
        if (this.$.audio.currentTime > subtitleData[i].startTime / 1000 &&
            this.$.audio.currentTime < subtitleData[i].endTime / 1000) {
              this.currentTitle = subtitleData[i].text;
            }
      }

      field.update();
      simulationShader.uniforms.tOldPos.value = fbo.out;
      simulationShader.uniforms.tTargetHead.value = dataTexturePosition;
      simulationShader.uniforms.tTargetStars.value = dataTextureStars;

      simulationShader.uniforms.fForceStars.value = this.forceStars / 4000;
      simulationShader.uniforms.fForceHead.value = this.forceHead / 4000;
      simulationShader.uniforms.fForceField.value = this.forceField / 40000;
      simulationShader.uniforms.fForceCenter.value = this.forceCenter / 100;
      //
      simulationShader.uniforms.ftex.value = field.texture;
      simulationShader.uniforms.ftrans.value = field.uniforms.ftrans.value;
      simulationShader.uniforms.finvTrans.value = field.uniforms.finvTrans.value;

      window.simulationShader = simulationShader;

      var time = Date.now();
      simulationShader.uniforms.vCenter.value.y = Math.sin(time / 10000) * 2 + 1;
      simulationShader.uniforms.vCenter.value.x = Math.cos(time / 30000) * 1;

      fbo.swap();
      fbo.simulate();

      particleMaterial.uniforms.tPositions.value = fbo.out;
      particleMaterial.uniforms.fColor.value = this.color / 100;

      // renderer.render(scene, camera);
      composer.render( 0.1 );

    }

  });
}());
</script>
