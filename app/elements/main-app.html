<script src="../lib/FBOUtils.js"></script>

<dom-module id="main-app">
  <template></template>
</dom-module>
<script>
(function () {

  var renderer = new THREE.WebGLRenderer({antialias: false});

  var scene = new THREE.Scene();

  var camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(-0.3, -0.2, 1.5);
  camera.lookAt(new THREE.Vector3());

  var dataTexturePosition = new THREE.DataTexture(null, 512, 512, THREE.RGBFormat, THREE.FloatType);
  dataTexturePosition.magFilter = THREE.NearestFilter;
  dataTexturePosition.minFilter = THREE.NearestFilter;
  dataTexturePosition.generateMipmaps = false;

  var xhr = new XMLHttpRequest();
  xhr.responseType = 'arraybuffer';
  xhr.open('GET', 'model/head.position.bin', true);
  xhr.onload = function(e) {
    var buffer = new Float32Array(xhr.response);
    dataTexturePosition.image.data = buffer;
    dataTexturePosition.needsUpdate = true;
  }
  xhr.send();

  var dataTextureColor = new THREE.DataTexture(null, 512, 512, THREE.RGBFormat, THREE.FloatType);
  dataTextureColor.magFilter = THREE.NearestFilter;
  dataTextureColor.minFilter = THREE.NearestFilter;
  dataTextureColor.generateMipmaps = false;

  var xhr2 = new XMLHttpRequest();
  xhr2.responseType = 'arraybuffer';
  xhr2.open('GET', 'model/head.color.bin', true);
  xhr2.onload = function(e) {
    var buffer = new Float32Array(xhr2.response);
    dataTextureColor.image.data = buffer;
    dataTextureColor.needsUpdate = true;
  }
  xhr2.send();

  var dataTextureStars = new THREE.DataTexture(null, 512, 512, THREE.RGBFormat, THREE.FloatType);
  dataTextureStars.magFilter = THREE.NearestFilter;
  dataTextureStars.minFilter = THREE.NearestFilter;
  dataTextureStars.generateMipmaps = false;

  var xhr3 = new XMLHttpRequest();
  xhr3.responseType = 'arraybuffer';
  xhr3.open('GET', 'model/stars.bin', true);
  xhr3.onload = function(e) {
    var buffer = new Float32Array(xhr3.response);
    dataTextureStars.image.data = buffer;
    dataTextureStars.needsUpdate = true;
  }
  xhr3.send();

  var dataTextureRandom = new THREE.DataTexture(null, 512, 512, THREE.RGBFormat, THREE.FloatType);
  dataTextureRandom.magFilter = THREE.NearestFilter;
  dataTextureRandom.minFilter = THREE.NearestFilter;
  dataTextureRandom.generateMipmaps = false;

  var xhr4 = new XMLHttpRequest();
  xhr4.responseType = 'arraybuffer';
  xhr4.open('GET', 'model/random.bin', true);
  xhr4.onload = function(e) {
    var buffer = new Float32Array(xhr4.response);
    dataTextureRandom.image.data = buffer;
    dataTextureRandom.needsUpdate = true;
  }
  xhr4.send();

  /////

  var size = 256;
  var count = size * size;

  var particleGeometry = new THREE.BufferGeometry();
  particleGeometry.attributes = {
    position: {
      itemSize: 3,
      array: new Float32Array(count * 3),
      numItems: count * 3
    },
    uv: {
      itemSize: 2,
      array: new Float32Array(count * 2),
      numItems: count * 2
    }
  }
  var positions = particleGeometry.attributes.position.array;
  var uvs = particleGeometry.attributes.uv.array;

  for (var i = 0; i < count; i ++) {
    // positions
    positions[i * 3]     = Math.random();
    positions[i * 3 + 1] = Math.random();
    positions[i * 3 + 2] = Math.random();
    // uvs
    uvs[i * 2]     = (i % size + 0.5) / size;
    uvs[i * 2 + 1] = (Math.floor(i / size + 0.5)) / size;
  }
  particleGeometry.computeBoundingSphere();

  var particleMaterial = new THREE.ShaderMaterial({

    uniforms: {
      tPositions: { type: "t", value: dataTexturePosition },
      tColors: { type: "t", value: dataTextureColor },
      tRandom: { type: "t", value: dataTextureRandom },
      pointSize: { type: "f", value: 2 }
    },

    vertexShader: [

			'uniform sampler2D tPositions;',
			'uniform sampler2D tRandom;',
			'uniform float pointSize;',

			'varying vec2 vUv;',

			'void main() {',

      ' vUv = uv;',

      ' vec3 texPosition = texture2D(tPositions, uv).rgb;',

      ' vec4 mvPosition = modelViewMatrix * vec4(texPosition, 1.0);',

      ' gl_Position = projectionMatrix * mvPosition;',

      ' gl_PointSize = (texture2D(tRandom, uv).r + 0.5) * 3.0;',

			'}'

		].join('\n'),

		fragmentShader: [

			'uniform sampler2D tColors;',

			'varying vec2 vUv;',

			'void main() {',

      ' vec3 texColor = texture2D(tColors, vUv).rgb;',

			'	gl_FragColor = vec4(texColor, 1.0);',

			'}'

		].join('\n')

  });

  var particleMesh = new THREE.PointCloud(particleGeometry, particleMaterial);
  scene.add(particleMesh);

  /////

  var simulationShader = new THREE.ShaderMaterial({

    uniforms: THREE.UniformsUtils.merge([{

      tOldPos: { type: "t", value: null },
      tTargetFace: { type: "t", value: null },
      tTargetStars: { type: "t", value: null }

    }, field.uniforms]),

    vertexShader: [

      'varying vec2 vUv;',

      'void main() {',

      '	vUv = uv; ',

      '	gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1);',

      '}'

		].join('\n'),

		fragmentShader: [

      field.shaderChunk.params,

			'uniform sampler2D tOldPos;',
			'uniform sampler2D tTargetFace;',
			'uniform sampler2D tTargetStars;',

			'varying vec2 vUv;',

      field.shaderChunk.functions,

			'void main() {',

      ' vec3 oldPos = texture2D(tOldPos, vUv).rgb;',

      ' float fieldIntensity = 0.0001;',
      ' vec3 field = getField(ftex, ftrans, finvTrans, oldPos, fgrid, fieldIntensity * 4.0);',

      ' vec3 targetFace = (texture2D(tTargetFace, vUv).rgb - oldPos) * 0.05;',

      ' vec3 targetStars = (texture2D(tTargetStars, vUv).rgb - oldPos) * 0.0001;',

			'	gl_FragColor = vec4(oldPos + targetStars + targetFace + field, 1.0);',

			'}'

		].join('\n')

  });

  var fbo = new THREE.FBOUtils( 512, renderer, simulationShader );

  /////



  var loop = function () {
    setTimeout(function(){
      requestAnimationFrame(loop);
    }, 1000 / 24); // temp

    field.update();
    simulationShader.uniforms.tOldPos.value = fbo.out;
    simulationShader.uniforms.tTargetFace.value = dataTexturePosition;
    simulationShader.uniforms.tTargetStars.value = dataTextureStars;
    //
    simulationShader.uniforms.ftex.value = field.texture;
    simulationShader.uniforms.ftrans.value = field.uniforms.ftrans.value;
    simulationShader.uniforms.finvTrans.value = field.uniforms.finvTrans.value;

    fbo.swap();
    fbo.simulate();

    particleMaterial.uniforms.tPositions.value = fbo.out;

    renderer.render(scene, camera);
  };

  scene.add(field.transform);
  loop();

  Polymer({
    is: 'main-app',
    properties: {
    },
    ready: function () {

      this.appendChild(renderer.domElement);
      renderer.setSize(window.innerWidth, window.innerHeight);

      window.addEventListener('resize', function() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });

    }
  });
}());
</script>
